<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Debugging kubernetes containers | Personal blog</title>
<meta name="keywords" content="kubernetes">
<meta name="description" content="The scenario: you have a running kubernetes cluster, but suddenly some of your containers start to have problems.
Obviously now there must be a way to find out what exactly is causing these problems.
In this post I&rsquo;ll highlight two ways to debug a container running on kubernetes:
ephemeral-containers (which is likely what you should use most of the time) nsenter (which is a last resort debugging option that requires access to the node the Pod is running on) Want to follow along?">
<meta name="author" content="Florian Bergmann">
<link rel="canonical" href="https://blog.niflheim.cc/posts/debugging_kubernetes_containers/">
<link crossorigin="anonymous" href="https://blog.niflheim.cc/assets/css/stylesheet.41d57c6d60ed753d1e30f2550c0e83c95e5df376fe471d353917de2dd6c9d7bd.css" integrity="sha256-QdV8bWDtdT0eMPJVDA6DyV5d83b&#43;Rx01ORfeLdbJ170=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.niflheim.cc/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.niflheim.cc/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.niflheim.cc/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.niflheim.cc/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.niflheim.cc/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Debugging kubernetes containers" />
<meta property="og:description" content="The scenario: you have a running kubernetes cluster, but suddenly some of your containers start to have problems.
Obviously now there must be a way to find out what exactly is causing these problems.
In this post I&rsquo;ll highlight two ways to debug a container running on kubernetes:
ephemeral-containers (which is likely what you should use most of the time) nsenter (which is a last resort debugging option that requires access to the node the Pod is running on) Want to follow along?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.niflheim.cc/posts/debugging_kubernetes_containers/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-01T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Debugging kubernetes containers"/>
<meta name="twitter:description" content="The scenario: you have a running kubernetes cluster, but suddenly some of your containers start to have problems.
Obviously now there must be a way to find out what exactly is causing these problems.
In this post I&rsquo;ll highlight two ways to debug a container running on kubernetes:
ephemeral-containers (which is likely what you should use most of the time) nsenter (which is a last resort debugging option that requires access to the node the Pod is running on) Want to follow along?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.niflheim.cc/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Debugging kubernetes containers",
      "item": "https://blog.niflheim.cc/posts/debugging_kubernetes_containers/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Debugging kubernetes containers",
  "name": "Debugging kubernetes containers",
  "description": "The scenario: you have a running kubernetes cluster, but suddenly some of your containers start to have problems.\nObviously now there must be a way to find out what exactly is causing these problems.\nIn this post I\u0026rsquo;ll highlight two ways to debug a container running on kubernetes:\nephemeral-containers (which is likely what you should use most of the time) nsenter (which is a last resort debugging option that requires access to the node the Pod is running on) Want to follow along?",
  "keywords": [
    "kubernetes"
  ],
  "articleBody": "The scenario: you have a running kubernetes cluster, but suddenly some of your containers start to have problems.\nObviously now there must be a way to find out what exactly is causing these problems.\nIn this post I’ll highlight two ways to debug a container running on kubernetes:\nephemeral-containers (which is likely what you should use most of the time) nsenter (which is a last resort debugging option that requires access to the node the Pod is running on) Want to follow along? Setup a test cluster and run the provided command to get your very own failing container:\n1--- 2apiVersion: v1 3kind: ConfigMap 4metadata: 5 name: myconfig 6 namespace: default 7data: 8 config.toml: | 9 [default] 10 additional_file: \"\" 11--- 12apiVersion: v1 13kind: Pod 14metadata: 15 name: my-broken-pod 16 namespace: default 17spec: 18 containers: 19 - name: working-container 20 image: gcr.io/google_containers/pause-amd64:3.0 21 - name: broken-container 22 image: quay.io/fbergman/broken-pod:latest 23 imagePullPolicy: IfNotPresent 24 resources: 25 limits: 26 memory: \"128Mi\" 27 cpu: \"500m\" 28 ports: 29 - containerPort: 3000 30 readinessProbe: 31 httpGet: 32 path: /readyz 33 port: 3000 34 volumeMounts: 35 - mountPath: /opt/ 36 name: configuration 37 volumes: 38 - name: configuration 39 configMap: 40 name: myconfig 1minikube start 2kubectl apply -f /some-web-url In this case one of the LivenessProbes starts failing.\nIn case of one container (working-container), there is no way to debug into it, because it does not contain any executable shell. This is a pretty common scenario when running minimal container images like distroless containers.\nThe other container allows spawning a shell, but is missing most utilities that would make debugging easier: there is no strace, no gdb and no default networking tools.\nHow can we now proceed to figure out what breaks the container starting?\nObviously we can hope that a kubectl describe pod or the logs of our application has some useful information, but let’s say this is not the case and running kubectl logs my-broken-pod simply returns nothing useful.\nIn this case the two already mentioned approaches can be used - as it should be your first stop let’s start with ephemeral containers:\nUsing ephemeral containers When having to debug a pod, ephemeral containers are the frist tool to use, because in general access to cluster nodes might not be available.\nWhen using ephemeral containers it is important to have some container images ready that contain tools you want to use for debugging.\nA very good network debugging container is the netshoot container.\nBut if all you need is a basic shell (in case of a distroless container) - busybox might already be enough.\nStarting an ephemeral container Ephemeral containers are handled as an additional field in the spec of a container: see the apidocs.\nEphemeral containers can only be added to an already running pod - trying to add them to a Pod during creation will result in an error:\n1--- 2apiVersion: v1 3kind: Pod 4metadata: 5 name: ephemeral-container-on-start 6 labels: 7 name: ephemeral-container-on-start 8spec: 9 containers: 10 - name: main-container 11 image: busybox:1.28 12 resources: 13 limits: 14 memory: \"64\" 15 cpu: \"250m\" 16 ephemeralContainers: 17 - name: debug-container 18 image: busybox:1.28 19 resources: 20 limits: 21 memory: \"64Mi\" 22 cpu: \"250m\" 1The Pod \"ephemeral-container-on-start\" is invalid: 2* spec.ephemeralContainers[0].resources: Forbidden: cannot be set for an Ephemeral Container 3* spec.ephemeralContainers: Forbidden: cannot be set on create That leaves two options to add an ephemeral container to a Pod:\nThe kubectl debug command: 1 kubectl debug -it [pod-name] --image=busybox:1.28 --target=[container-name] Patching the Pod using the API directly using the new resource: 1 # Just for this experiment, give the default serviceaccount all permissions 2 kubectl create clusterrolebinding --clusterrole cluster-admin --serviceaccount default:default default-all-permissions 3 # APIURL 4 APIURL=$(kubectl config view --minify --output jsonpath=\"{.clusters[*].cluster.server}\") 5 # Impersonate a serviceaccount with the required privileges 6 TOKEN=$(kubectl create token default) 7 # Call the API using curl as this serviceaccount 8 curl --header \"Authorization: Bearer $TOKEN\" \\ 9 --header \"Content-Type: application/strategic-merge-patch+json\" \\ 10 --request PATCH \\ 11 -d ' 12 { 13 \"spec\": 14 { 15 \"ephemeralContainers\": 16 [ 17 { 18 \"name\": \"debugger\", 19 \"command\": [\"sh\"], 20 \"image\": \"busybox\", 21 \"targetContainerName\": \"broken-container\", 22 \"stdin\": true, 23 \"tty\": true, 24 \"volumeMounts\": [] 25 } 26 ] 27 } 28 }' \\ 29 \"${APIURL}/api/v1/namespaces/default/pods/my-broken-pod/ephemeralcontainers\" -k Once the container has been added like that it can be used using kubectl exec -ti my-broken-pod -c debugger sh. Getting rid of the new container can be done, by killing the process that was already running when execing into the container: kill -9 . What will not work is using kubectl edit, as this is explicitly not supported:\nEphemeral containers are created using a special ephemeralcontainers handler in the API rather than by adding them directly to pod.spec, so it’s not possible to add an ephemeral container using kubectl edit.\nOnce the container is launched (and you either already are inside the shell when using kubectl debug or have attached via kubectl exec) you can run whatever commands might be necessary.\nCleaning up ephemeral containers Checking the apidocs also shows what might be an issue for some user:\nEphemeral containers may not be removed or restarted.\nSo - once a ephemeral container has been added to a Pod, the only way to completely get rid of it from the Pod spec is by recreating the Pod without it.\nIt’s also strongly recommended to not keep a process running in the ephemeral container, because it will work against the requests and limits of the entire pod:\nThe kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.\nUsing nsenter Using nsenter will not only work for kubernetes pods, so this is something you can also use for docker or podman containers.\nGenerally this is useful if you want to pick-and-choose which namespaces of the container you want to access.\nIn kubernetes this will only work, if there is a way to gain access to the cluster node the Pod you want to debug is running on.\nSo either via ssh or using a openshift debug node/NODE container.\nOnce access to the node is established the process running inside the pod needs to be found: a lot of these commands depend on the container runtime in use, so for the remainder I will assume the cluster is using CRIO.1\nFind the Pod ID for our my-broken-pod pod: 1 POD_ID=$(crictl pods --name my-broken-pod -o json | jq -r '.items[] | select(.state == \"SANDBOX_READY\") | .id') Find all processes inside this pod: 1 CONTAINERS=$(crictl ps --pod d718ccb51d73896035324f6d9d9d12cc6818027ab18e5f78b295b518c62b46bd -o json | jq -r '.containers[].id') Find all processes inside these containers (or just choose the one container that is running the crashing process): 1 crictl inspect 154c67e44fcc843201aa582214395c82eb0e40acfda1ef1a9e12567f371aa13d | jq -r \".info.pid\" With the PID it is now possible to enter some of the namespaces of this process, while maintaining access to all binaries installed on the machine we SSHed to (as long as the mount namespace is not used with nsenter - indicated by the -m flag):\n1PID=1234 2nsenter -t $PID -n -p -u Often it can be useful to add namespaces incrementally to see if one of the namespaces might have an impact on the container’s behaviour.\nIn this case it’s now possible to inspect the process that is refusing to work with all tools available on the host - in case of a minikube cluster this includes tools like lsof and strace.\nBut first let’s check if the ReadinessProbe works right now:\n1curl -I localhost:3000/readyz 1HTTP/1.1 500 Internal Server Error 2content-type: text/plain; charset=utf-8 3content-length: 7 4date: Fri, 01 Dec 2023 11:16:12 GMT So it is returning a 500 error - maybe we can get some more information what the process is actually doing using strace:\n1strace -f -p \"$PID\" 1[pid 128904] epoll_wait(3, 2[pid 128893] futex(0x7f6985695940, FUTEX_WAIT_PRIVATE, 1, NULL 3[pid 128904] \u003c... epoll_wait resumed\u003e[], 1024, 202) = 0 4[pid 128904] epoll_wait(3, [], 1024, 17) = 0 5[pid 128904] statx(AT_FDCWD, \"/opt/config/additional_file\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0 6[pid 128904] write(1, \"app_state bad - configuration at\"..., 61) = 61 7[pid 128904] write(4, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8) = 8 It seems to stat a configuration file at /opt/config/additional_file - that’s strange, as the configuration should live in another file (config.toml)2.\nTime to actually use the mount namespace and see what’s in /opt/config\n1nsenter -t $PID -n -p -u -m 2ls /opt/config 1additional_file config.toml Well the file is there - so let’s update our configuration to not contain it and see if it unbreaks our application:\n1kubectl patch -n default configmaps myconfig --type=json -p '[{\"op\": \"remove\", \"path\": \"/data/additional_file\"}]' After removing that key from the ConfigMap and a Pod restart it seems our application is finally happy!\n1my-broken-pod 2/2 Running 0 10s Obviously in this case the strace command could also have been run directly from the node, but knowing how to incrementally add container namespaces can still be useful - e.g. to check how a mounted filesystem really looks like inside the container.\nReferences Ephemeral containers (official documentation) Ephemeral containers (great blog post) nsenter man page If the process is easy to identify running ps and grepping for the process commandline will also work. ↩︎\nObviously in this example this file was mounted from the ConfigMap - in reality this might indicate problems with other software that might inject libraries into all processes via LD_PRELOAD modifications. ↩︎\n",
  "wordCount" : "1556",
  "inLanguage": "en",
  "datePublished": "2023-12-01T00:00:00Z",
  "dateModified": "2023-12-01T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Florian Bergmann"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.niflheim.cc/posts/debugging_kubernetes_containers/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Personal blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.niflheim.cc/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.niflheim.cc/" accesskey="h" title="Personal blog (Alt + H)">Personal blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.niflheim.cc/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://blog.niflheim.cc/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Debugging kubernetes containers
    </h1>
    <div class="post-meta"><span title='2023-12-01 00:00:00 +0000 UTC'>December 1, 2023</span>&nbsp;·&nbsp;Florian Bergmann

</div>
  </header> 
  <div class="post-content"><p>The scenario: you have a running kubernetes cluster, but suddenly some of your
containers start to have problems.</p>
<p>Obviously now there must be a way to find out what exactly is causing these
problems.</p>
<p>In this post I&rsquo;ll highlight two ways to debug a container running on kubernetes:</p>
<ul>
<li><code>ephemeral-containers</code> (which is likely what you should use most of the time)</li>
<li><code>nsenter</code> (which is a last resort debugging option that requires access to the
node the Pod is running on)</li>
</ul>
<blockquote>
<p>Want to follow along? Setup a test cluster and run the provided command to get
your very own failing container:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myconfig</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">  </span><span class="nt">config.toml</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="sd">    [default]</span><span class="w">    
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span><span class="nt">additional_file</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-broken-pod</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">working-container</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">gcr.io/google_containers/pause-amd64:3.0</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">broken-container</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">quay.io/fbergman/broken-pod:latest</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">    </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">    </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">      </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">        </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;128Mi&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">        </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;500m&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">      </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">    </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">      </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">        </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/readyz</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w">        </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">    </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">      </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/opt/</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">configuration</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">configuration</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">      </span><span class="nt">configMap</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myconfig</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">minikube start
</span></span><span class="line"><span class="ln">2</span><span class="cl">kubectl apply -f /some-web-url
</span></span></code></pre></div></blockquote>
<p>In this case one of the <code>LivenessProbes</code> starts failing.</p>
<p>In case of one container (<code>working-container</code>), there is no way to debug into
it, because it does not contain any executable shell. This is a pretty common
scenario when running minimal container images like <a href="https://github.com/GoogleContainerTools/distroless">distroless</a> containers.</p>
<p>The other container allows spawning a shell, but is missing most utilities that
would make debugging easier: there is no <code>strace</code>, no <code>gdb</code> and no default
networking tools.</p>
<p>How can we now proceed to figure out what breaks the container starting?</p>
<p>Obviously we can hope that a <code>kubectl describe pod</code> or the logs of our
application has some useful information, but let&rsquo;s say this is not the case and
running <code>kubectl logs my-broken-pod</code> simply returns nothing useful.</p>
<p>In this case the two already mentioned approaches can be used - as it should be
your first stop let&rsquo;s start with <strong>ephemeral containers</strong>:</p>
<h2 id="using-ephemeral-containers">Using ephemeral containers<a hidden class="anchor" aria-hidden="true" href="#using-ephemeral-containers">#</a></h2>
<p>When having to debug a pod, ephemeral containers are the frist tool to use,
because in general access to cluster nodes might not be available.</p>
<p>When using ephemeral containers it is important to have some container images
ready that contain tools you want to use for debugging.</p>
<p>A very good network debugging container is the <a href="https://github.com/nicolaka/netshoot">netshoot</a> container.</p>
<p>But if all you need is a basic shell (in case of a distroless container) -
busybox might already be enough.</p>
<h3 id="starting-an-ephemeral-container">Starting an ephemeral container<a hidden class="anchor" aria-hidden="true" href="#starting-an-ephemeral-container">#</a></h3>
<p>Ephemeral containers are handled as an additional field in the <code>spec</code> of a
container: <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#ephemeralcontainer-v1-core">see the apidocs</a>.</p>
<p>Ephemeral containers can only be added to an already running pod - trying to add
them to a Pod during creation will result in an error:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">ephemeral-container-on-start</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">ephemeral-container-on-start</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">main-container</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">busybox:1.28</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">      </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">        </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;64&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">        </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;250m&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">  </span><span class="nt">ephemeralContainers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">debug-container</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">busybox:1.28</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">    </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">      </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">        </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;64Mi&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">        </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;250m&#34;</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">The Pod <span class="s2">&#34;ephemeral-container-on-start&#34;</span> is invalid:
</span></span><span class="line"><span class="ln">2</span><span class="cl">* spec.ephemeralContainers<span class="o">[</span>0<span class="o">]</span>.resources: Forbidden: cannot be <span class="nb">set</span> <span class="k">for</span> an Ephemeral Container
</span></span><span class="line"><span class="ln">3</span><span class="cl">* spec.ephemeralContainers: Forbidden: cannot be <span class="nb">set</span> on create
</span></span></code></pre></div><p>That leaves two options to add an ephemeral container to a Pod:</p>
<ol>
<li>The <code>kubectl debug</code> command:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">   kubectl debug -it <span class="o">[</span>pod-name<span class="o">]</span> --image<span class="o">=</span>busybox:1.28 --target<span class="o">=[</span>container-name<span class="o">]</span>
</span></span></code></pre></div></li>
<li>Patching the Pod using the API directly using the new resource:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln"> 1</span><span class="cl">   <span class="c1"># Just for this experiment, give the default serviceaccount all permissions</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">   kubectl create clusterrolebinding --clusterrole cluster-admin --serviceaccount default:default default-all-permissions
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="c1"># APIURL</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="nv">APIURL</span><span class="o">=</span><span class="k">$(</span>kubectl config view --minify --output <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.clusters[*].cluster.server}&#34;</span><span class="k">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="c1"># Impersonate a serviceaccount with the required privileges</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="nv">TOKEN</span><span class="o">=</span><span class="k">$(</span>kubectl create token default<span class="k">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   <span class="c1"># Call the API using curl as this serviceaccount</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">   curl --header <span class="s2">&#34;Authorization: Bearer </span><span class="nv">$TOKEN</span><span class="s2">&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="se"></span>       --header <span class="s2">&#34;Content-Type: application/strategic-merge-patch+json&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="se"></span>       --request PATCH <span class="se">\
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="se"></span>       -d <span class="s1">&#39;
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="s1">   {
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="s1">       &#34;spec&#34;:
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="s1">       {
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="s1">           &#34;ephemeralContainers&#34;:
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="s1">           [
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="s1">               {
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="s1">                   &#34;name&#34;: &#34;debugger&#34;,
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="s1">                   &#34;command&#34;: [&#34;sh&#34;],
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="s1">                   &#34;image&#34;: &#34;busybox&#34;,
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="s1">                   &#34;targetContainerName&#34;: &#34;broken-container&#34;,
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="s1">                   &#34;stdin&#34;: true,
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="s1">                   &#34;tty&#34;: true,
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="s1">                   &#34;volumeMounts&#34;: []
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="s1">               }
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="s1">           ]
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="s1">       }
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="s1">   }&#39;</span> <span class="se">\
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="se"></span>       <span class="s2">&#34;</span><span class="si">${</span><span class="nv">APIURL</span><span class="si">}</span><span class="s2">/api/v1/namespaces/default/pods/my-broken-pod/ephemeralcontainers&#34;</span> -k
</span></span></code></pre></div>Once the container has been added like that it can be used using <code>kubectl exec -ti my-broken-pod -c debugger sh</code>. Getting rid of the new container can
be done, by killing the process that was already running when <code>execing</code> into
the container: <code>kill -9 &lt;pid_of_initial_sh&gt;</code>.</li>
</ol>
<p>What will not work is using <code>kubectl edit</code>, as this is <a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/#what-is-an-ephemeral-container">explicitly not supported</a>:</p>
<blockquote>
<p>Ephemeral containers are created using a special ephemeralcontainers handler in the API rather than by adding them directly to pod.spec, so it&rsquo;s not possible to add an ephemeral container using kubectl edit.</p>
</blockquote>
<p>Once the container is launched (and you either already are inside the shell when
using <code>kubectl debug</code> or have attached via <code>kubectl exec</code>) you can run whatever
commands might be necessary.</p>
<h3 id="cleaning-up-ephemeral-containers">Cleaning up ephemeral containers<a hidden class="anchor" aria-hidden="true" href="#cleaning-up-ephemeral-containers">#</a></h3>
<p>Checking the apidocs also shows what might be an issue for some user:</p>
<blockquote>
<p>Ephemeral containers may not be removed or restarted.</p>
</blockquote>
<p>So - once a ephemeral container has been added to a Pod, the only way to
completely get rid of it from the Pod spec is by recreating the Pod without it.</p>
<p>It&rsquo;s also strongly recommended to not keep a process running in the ephemeral
container, because it will work against the requests and limits of the entire
pod:</p>
<blockquote>
<p>The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.</p>
</blockquote>
<h2 id="using-nsenter">Using nsenter<a hidden class="anchor" aria-hidden="true" href="#using-nsenter">#</a></h2>
<p>Using <code>nsenter</code> will not only work for kubernetes pods, so this is something you
can also use for <code>docker</code> or <code>podman</code> containers.</p>
<p>Generally this is useful if you want to pick-and-choose which <strong>namespaces</strong> of
the container you want to access.</p>
<blockquote>
<p>In kubernetes this will only work, if there is a way to gain access to the
cluster node the Pod you want to debug is running on.</p>
<p>So either via <code>ssh</code> or using a <a href="https://www.redhat.com/sysadmin/how-oc-debug-works">openshift debug node/NODE</a> container.</p>
</blockquote>
<p>Once access to the node is established the process running inside the pod needs
to be found: a lot of these commands depend on the container runtime in use, so
for the remainder I will assume the cluster is using <code>CRIO</code>.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<ol>
<li>Find the Pod ID for our <code>my-broken-pod</code> pod:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">   <span class="nv">POD_ID</span><span class="o">=</span><span class="k">$(</span>crictl pods --name my-broken-pod -o json <span class="p">|</span> jq -r <span class="s1">&#39;.items[] | select(.state == &#34;SANDBOX_READY&#34;) | .id&#39;</span><span class="k">)</span>
</span></span></code></pre></div></li>
<li>Find all processes inside this pod:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">   <span class="nv">CONTAINERS</span><span class="o">=</span><span class="k">$(</span>crictl ps --pod d718ccb51d73896035324f6d9d9d12cc6818027ab18e5f78b295b518c62b46bd -o json <span class="p">|</span> jq -r <span class="s1">&#39;.containers[].id&#39;</span><span class="k">)</span>
</span></span></code></pre></div></li>
<li>Find all processes inside these containers (or just choose the one container that is running the crashing process):
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">   crictl inspect 154c67e44fcc843201aa582214395c82eb0e40acfda1ef1a9e12567f371aa13d <span class="p">|</span> jq -r <span class="s2">&#34;.info.pid&#34;</span>
</span></span></code></pre></div></li>
</ol>
<p>With the <code>PID</code> it is now possible to enter some of the namespaces of this
process, while maintaining access to all binaries installed on the machine we
SSHed to (as long as the <code>mount</code> namespace is <strong>not</strong> used with <code>nsenter</code> -
indicated by the <code>-m</code> flag):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl"><span class="nv">PID</span><span class="o">=</span><span class="m">1234</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">nsenter -t <span class="nv">$PID</span> -n -p -u
</span></span></code></pre></div><p>Often it can be useful to add <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">namespaces</a> incrementally to see if one of the
namespaces might have an impact on the container&rsquo;s behaviour.</p>
<p>In this case it&rsquo;s now possible to inspect the process that is refusing to work
with all tools available on the host - in case of a <code>minikube</code> cluster this
includes tools like <code>lsof</code> and <code>strace</code>.</p>
<p>But first let&rsquo;s check if the <code>ReadinessProbe</code> works right now:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">curl -I localhost:3000/readyz
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">HTTP/1.1 500 Internal Server Error
</span></span><span class="line"><span class="ln">2</span><span class="cl">content-type: text/plain; charset=utf-8
</span></span><span class="line"><span class="ln">3</span><span class="cl">content-length: 7
</span></span><span class="line"><span class="ln">4</span><span class="cl">date: Fri, 01 Dec 2023 11:16:12 GMT
</span></span></code></pre></div><p>So it is returning a <strong>500</strong> error - maybe we can get some more information what
the process is actually doing using strace:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">strace -f -p <span class="s2">&#34;</span><span class="nv">$PID</span><span class="s2">&#34;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">[pid 128904] epoll_wait(3,  &lt;unfinished ...&gt;
</span></span><span class="line"><span class="ln">2</span><span class="cl">[pid 128893] futex(0x7f6985695940, FUTEX_WAIT_PRIVATE, 1, NULL &lt;unfinished ...&gt;
</span></span><span class="line"><span class="ln">3</span><span class="cl">[pid 128904] &lt;... epoll_wait resumed&gt;[], 1024, 202) = 0
</span></span><span class="line"><span class="ln">4</span><span class="cl">[pid 128904] epoll_wait(3, [], 1024, 17) = 0
</span></span><span class="line"><span class="ln">5</span><span class="cl">[pid 128904] statx(AT_FDCWD, &#34;/opt/config/additional_file&#34;, AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0
</span></span><span class="line"><span class="ln">6</span><span class="cl">[pid 128904] write(1, &#34;app_state bad - configuration at&#34;..., 61) = 61
</span></span><span class="line"><span class="ln">7</span><span class="cl">[pid 128904] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
</span></span></code></pre></div><p>It seems to <code>stat</code> a configuration file at <code>/opt/config/additional_file</code> -
that&rsquo;s strange, as the configuration should live in another file
(<code>config.toml</code>)<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>Time to actually use the mount namespace and see what&rsquo;s in <code>/opt/config</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">nsenter -t <span class="nv">$PID</span> -n -p -u -m
</span></span><span class="line"><span class="ln">2</span><span class="cl">ls /opt/config
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">additional_file  config.toml
</span></span></code></pre></div><p>Well the file is there - so let&rsquo;s update our configuration to not contain it and
see if it unbreaks our application:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">kubectl patch -n default configmaps myconfig --type<span class="o">=</span>json -p <span class="s1">&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/data/additional_file&#34;}]&#39;</span>
</span></span></code></pre></div><p>After removing that key from the <code>ConfigMap</code> and a Pod restart it seems our
application is finally happy!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">my-broken-pod   2/2     Running   0          10s
</span></span></code></pre></div><blockquote>
<p>Obviously in this case the <code>strace</code> command could also have been run directly
from the node, but knowing how to incrementally add container namespaces can
still be useful - e.g. to check how a mounted filesystem really looks like
inside the container.</p>
</blockquote>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/">Ephemeral containers (official documentation)</a></li>
<li><a href="https://iximiuz.com/en/posts/kubernetes-ephemeral-containers/">Ephemeral containers (great blog post)</a></li>
<li><a href="https://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter man page</a></li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>If the process is easy to identify running <code>ps</code> and grepping for the
process commandline will also work.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Obviously in this example this file was mounted from the <code>ConfigMap</code> - in
reality this might indicate problems with other software that might inject
libraries into all processes via <code>LD_PRELOAD</code> modifications.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.niflheim.cc/tags/kubernetes/">kubernetes</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.niflheim.cc/">Personal blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
